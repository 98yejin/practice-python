



















[threading.Thread 클래스를 상속받는 이유]



Philosopher 클래스가 쓰레드로서의 기능을 포함하기 위해서입니다. Python의 threading 모듈을 사용하여 멀티 스레딩을 구현할 때, Thread 클래스를 상속하는 것은 다음과 같은 이점을 제공합니다:



1. 커스텀 쓰레드 동작 정의

Thread 클래스를 상속받으면, 쓰레드의 실행 흐름을 제어하는 run() 메소드를 오버라이드(재정의)하여 커스텀 동작을 구현할 수 있습니다. 이것은 쓰레드가 시작될 때 실행할 코드를 정의하는 기본적인 방법입니다. 예를 들어, Philosopher 클래스에서는 철학자가 생각하고, 배고픔을 느끼고, 식사하고, 다시 생각하는 일련의 동작을 run() 메소드 내에서 정의하고 있습니다.



2. 쓰레드 생명주기 관리

Thread 클래스를 상속받으면, 쓰레드의 생명주기를 관리할 수 있는 메소드들(start(), join(), is_alive() 등)을 자동으로 사용할 수 있습니다. 이 메소드들은 쓰레드를 시작, 종료, 그리고 모니터링하는 데 필요합니다. 예를 들어, start() 메소드를 호출하면 Thread 클래스의 run() 메소드가 자동으로 호출되고 쓰레드가 실행됩니다.



3. 자원 관리와 동기화

멀티 스레딩 환경에서 자원을 공유하거나 접근을 동기화해야 할 필요가 있을 때, threading 모듈은 Lock, Event, Condition 등 다양한 동기화 메커니즘을 제공합니다. Thread 클래스를 상속받으면 이러한 동기화 객체를 쓰레드 내에서 직접 관리하고 사용할 수 있습니다. Philosopher 예제에서는 두 개의 Lock 객체(포크)를 사용하여 식사 중인 철학자들 사이의 상호 작용을 동기화하고 있습니다.



4. 코드의 명확성과 구조화

Thread 클래스를 상속받아 사용하면, 멀티 스레딩을 적용한 프로그램의 코드 구조가 명확해지고, 각 쓰레드의 역할과 동작이 분명히 구분됩니다. 이는 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.

종합하면, Philosopher 클래스가 Thread를 상속받는 것은 멀티 스레딩 프로그램을 보다 효율적으로 구현하고 관리하기 위한 선택입니다. 이를 통해 각 철학자가 독립적인 실행 흐름을 가진 쓰레드로 동작하게 되어, 복잡한 동기화 로직을 더 쉽게 처리할 수 있습니다.





[if __name__ == ‘__main__’:구문]



스크립트가 직접 실행될 때만 특정 코드를 실행하도록 하기 위해 사용됩니다. 이 구문의 목적과 사용 방법을 구체적으로 설명드리겠습니다.

목적

직접 실행 vs. 모듈로 임포트: Python 파일은 두 가지 방식으로 사용될 수 있습니다. 하나는 스크립트나 프로그램으로서 직접 실행하는 경우이고, 다른 하나는 모듈로서 다른 스크립트에 임포트되어 사용되는 경우입니다. if __name__ == '__main__': 구문을 사용하면 이 두 상황을 구분하여, 파일이 직접 실행될 때만 특정 코드가 실행되도록 할 수 있습니다.

코드의 재사용: 이 구문을 사용함으로써 같은 스크립트를 모듈로서 재사용하는 경우에는 함수나 클래스 같은 정의들만을 로드하고, 스크립트가 직접 실행될 때만 실행되어야 하는 코드는 실행되지 않도록 할 수 있습니다. 이는 코드의 재사용성을 높여줍니다.

테스트와 디버깅 용이성: 개발 중에 스크립트를 독립적으로 실행하여 테스트하고 디버깅할 수 있습니다. 모듈로 임포트될 때는 부작용(side effects) 없이 필요한 함수나 클래스들만 제공합니다.



[파이썬의 라이프사이클 관리]



1. 프로그램 실행

소스 코드 해석: 파이썬 프로그램이 시작되면, 파이썬 인터프리터는 먼저 소스 코드를 읽어 들입니다. 이 코드는 텍스트 파일(.py) 형태일 수도 있고, 이미 컴파일된 바이트코드(.pyc)일 수도 있습니다.

컴파일: 소스 코드는 파이썬의 내장 컴파일러에 의해 바이트코드로 변환됩니다. 이 바이트코드는 파이썬 가상 머신(PVM)이 이해할 수 있는 중간 형태의 코드입니다.

실행: 컴파일된 바이트코드는 파이썬 가상 머신에 의해 실행됩니다. PVM은 스택 기반의 인터프리터로서, 하나하나의 연산을 순차적으로 처리합니다.

2. 메모리 관리 및 가비지 컬렉션

자동 메모리 관리: 파이썬은 자동 메모리 관리를 제공합니다. 개발자는 객체 생성에만 집중하면, 생성된 객체의 메모리 할당은 파이썬 인터프리터가 자동으로 처리합니다.

참조 카운팅: 파이썬은 객체의 참조 수를 추적하여 참조 카운트가 0이 되는 순간 객체를 메모리에서 해제합니다. 이는 가장 기본적인 메모리 관리 방식입니다.

가비지 컬렉션: 참조 카운팅만으로는 해결할 수 없는 순환 참조 문제를 해결하기 위해 파이썬은 가비지 컬렉터를 포함하고 있습니다. 이는 주기적으로 메모리를 검사하여 도달할 수 없는 객체들을 찾아 메모리에서 해제합니다.

세대별 수집(Generational Collection): 파이썬은 세대별 가비지 컬렉션 알고리즘을 사용합니다. 이는 객체를 생성된 지 얼마나 오래되었는지에 따라 여러 세대로 나누어 관리합니다. 젊은 세대의 객체에서 발생하는 가비지는 빈번하게 수집하고, 나이가 많은 세대는 덜 자주 수집합니다. 이 방법은 메모리 관리 효율을 최적화합니다.

3. 종료 처리

정리 작업: 프로그램이 종료될 때, 파이썬 인터프리터는 열려 있는 파일 핸들을 닫고, 네트워크 연결을 종료하고, 프로세스에 할당된 모든 시스템 리소스를 정리합니다.

종료 코드 반환: 프로그램이 성공적으로 종료되었는지 또는 오류로 인해 종료되었는지를 나타내는 종료 코드를 운영 체제에 반환합니다.





[시스템 디자인]

functional requirements 같이 정하기

Nonfunctional requirements 도 같이 정하기

Storage 얼마나 사용할 지 합의하기

High level Architecture 이야기하고 같은 그림을 그리는지 확인하기

DB Schema 이야기하기

SQL, NoSQL 중 뭐 사용할 지 이야기하기

SQL : Good in General, Complexity Query like JOIN, frequently look at the relationship between data

NoSQL : faster for writes, simple key-value reads, easy to scale out 





